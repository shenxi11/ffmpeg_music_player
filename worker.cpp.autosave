#include "worker.h"

Worker::Worker():
    
    isPaused(false)
  ,audioOutput(nullptr)
{
    timer = new QTimer(this);
    timer1 = new QTimer(this);
    
    
    connect(timer, &QTimer::timeout, this,&Worker::onTimeOut);
    
    connect(timer1, &QTimer::timeout, this, [=]() {
        emit durations(audioOutput->processedUSecs());
    });
    
    
}
Worker::~Worker() {
    
    
    timer->stop();
    timer1->stop();
    
    qDebug()<<"Destruct Worker";
}

void Worker::stop(){
    
}
void Worker::receive_lrc(std::map<int, std::string> lyrics){
    std::lock_guard<std::mutex>lock(mtx);
    this->lyrics=lyrics;
}
void  Worker::begin_play(QString pcmFilePath){
    //qDebug()<<"Worker"<<QThread::currentThreadId();
    emit play(pcmFilePath);
    
}
void Worker::stop_play(){
    emit stopPlay();
}
void Worker::Set_Volume(int value){
    if(audioOutput)
        audioOutput->setVolume(value/100.0);
}
void Worker::Pause(){
    if (!isPaused) {
        qDebug() << "暂停";
        audioOutput->suspend();
        timer->stop();
        timer1->stop();
        isPaused = true;
        qDebug() << "Playback paused CC:";
        emit Stop();
    } else if (isPaused) {
        qDebug() << "恢复";
        audioOutput->resume();
        isPaused = false;
        timer->start();
        timer1->start();
        emit Begin();
        qDebug() << "Playback resumed.";
    }
}
//void Worker::play_pcm(QString pcmFilePath ){

//    qDebug()<<"Worker"<<QThread::currentThreadId();
//    if (file) {
//        file->close();
//        file.reset();
//    }
//    if(audioOutput){
//        isPaused=false;
//        audioOutput->stop();
//        audioOutput->reset();
//        delete audioOutput;
//        qDebug()<<"重播";
//        if(buffer){
//            delete [] buffer;
//        }
//        disconnect(this,&Worker::stopPlay,this,nullptr);
//    }
//    file = std::make_unique<QFile>(pcmFilePath);
//    if (!file->open(QIODevice::ReadOnly)) {
//        qDebug() << "Failed to open file for reading:" << file->errorString();
//        return;
//    }

//    QAudioFormat format;
//    format.setSampleRate(44100);
//    format.setChannelCount(2);
//    format.setSampleSize(16);
//    format.setCodec("audio/pcm");
//    format.setByteOrder(QAudioFormat::LittleEndian);
//    format.setSampleType(QAudioFormat::SignedInt);

//    audioOutput =new QAudioOutput(format, this);
//    audioOutput->setBufferSize(8192 * 8);

//    audioDevice = audioOutput->start();
//    if (!audioDevice) {
//        qDebug() << "Failed to start audio device";
//        file->close();
//        file.reset();
//        return;
//    }

//    audioOutput->setVolume(50/100.0);


//    buffer = new char[bufferSize];

//    timer = new QTimer(this);
//    timer1= new QTimer(this);
//    int currentLyricIndex = 0;  // 用于追踪当前歌词的位置
//    connect(timer, &QTimer::timeout, this, [=]() mutable {
//        if (audioOutput->bytesFree() < bufferSize) {
//            // 缓冲区尚未腾出足够的空间，稍后再试
//            return;
//        }

//        qint64 bytesRead = file->read(buffer, bufferSize);

//        if (bytesRead > 0) {
//            qint64 bytesWritten = audioDevice->write(buffer, bytesRead);
//            if (bytesWritten < 0) {
//                qDebug() << "Error writing audio data:" << audioDevice->errorString();
//                timer->stop();
//                timer1->stop();
//                delete[] buffer;
//                file->close();
//                file.reset();
//                return;
//            }

//            // 获取当前音频播放的微秒数，并将其转换为毫秒
//            qint64 currentTimeMS = audioOutput->processedUSecs() / 1000;

//            // 遍历歌词并同步显示
//            if (!lyrics.empty() && currentLyricIndex < (int)lyrics.size()) {
//                auto it = std::next(lyrics.begin(), currentLyricIndex);  // 获取当前歌词
//                if (currentTimeMS >= it->first) {
//                    if(it->second!="")
//                        emit send_lrc(QString::fromStdString(it->second));
//                    currentLyricIndex++;  // 更新到下一条歌词
//                }
//            }
//        } else {
//            // 文件读取完毕，停止定时器
//            timer->stop();
//            timer1->stop();
//            qDebug() << "Playback finished AA";
//            delete[] buffer;
//            file->close();
//            file.reset();
//            emit Stop();
//            emit rePlay();
//            disconnect(this,&Worker::stopPlay,this,nullptr);
//        }
//    });


//    timer->start(10);  // 每10毫秒检查一次
//    timer1->start(1000);
//    emit Begin();

//    connect(timer1,&QTimer::timeout,this,[=](){
//        emit durations(audioOutput->processedUSecs());
//    });


//    connect(this, &Worker::stopPlay, this, [=]() mutable {

//        //qDebug()<<pcmFilePath;
//        if (!isPaused) {
//            // 暂停播放
//            qDebug() << "暂停";
//            audioOutput->suspend();
//            timer->stop();
//            timer1->stop();
//            isPaused = true;
//            qDebug() << "Playback paused CC:";
//            emit Stop();
//        } else if (isPaused) {
//            // 恢复播放
//            qDebug() << "恢复";
//            audioOutput->resume();
//            isPaused = false;
//            timer->start();
//            timer1->start();
//            emit Begin();
//            qDebug() << "Playback resumed.";
//        }

//    });
//}

void Worker::onTimeOut(){
    if (audioOutput->bytesFree() < bufferSize) {
        return;
    }
    
    qint64 bytesRead = file->read(buffer.get(), bufferSize);
    
    if (bytesRead > 0) {
        qint64 bytesWritten = audioDevice->write(buffer.get(), bytesRead);
        if (bytesWritten < 0) {
            qDebug() << "Error writing audio data:" << audioDevice->errorString();
            timer->stop();
            timer1->stop();
            file->close();
            file.reset();
            return;
        }
        
        qint64 currentTimeMS = audioOutput->processedUSecs() / 1000;
        {
            std::lock_guard<std::mutex>lock(mtx);
            
            if (!lyrics.empty() && currentLyricIndex < (int)lyrics.size()) {
                auto it = std::next(lyrics.begin(), currentLyricIndex);
                if (currentTimeMS >= it->first) {
                    if (it->second != "")
                        emit send_lrc(QString::fromStdString(it->second));
                    currentLyricIndex++;
                }
            }
        }
    } else {
        timer->stop();
        timer1->stop();
        qDebug() << "Playback finished AA";
        file->close();
        file.reset();
        emit Stop();
        emit rePlay();
        disconnect(this, &Worker::stopPlay, this, nullptr);
    }
}
void Worker::play_pcm(QString pcmFilePath) {
    
    qDebug() << "Worker" << QThread::currentThreadId();
    
    // 1. 停止并清理当前播放
    if (file) {
        file->close();
        file.reset();
    }
    
    if (audioOutput) {
        audioOutput->stop();
        audioOutput->reset();
        //        delete audioOutput;
        //        audioOutput = nullptr;
        
        timer->stop();
        timer1->stop();
        
        disconnect(this, &Worker::stopPlay, this, nullptr);
        
        if(buffer){
            qDebug()<<"缓冲区未处理"<<sizeof (buffer)<<"bytes";
        }
    }
    
    //    if (timer) {
    //        timer->stop();
    //        delete timer;
    //        timer = nullptr;
    //    }
    
    //    if (timer1) {
    //        timer1->stop();
    //        delete timer1;
    //        timer1 = nullptr;
    //    }
    
    //    if (buffer) {
    //        delete[] buffer;
    //        buffer = nullptr;
    //    }
    
    
    
    // 2. 重新初始化并开始播放
    file = std::make_unique<QFile>(pcmFilePath);
    if (!file->open(QIODevice::ReadOnly)) {
        qDebug() << "Failed to open file for reading:" << file->errorString();
        return;
    }
    
    QAudioFormat format;
    format.setSampleRate(44100);
    format.setChannelCount(2);
    format.setSampleSize(16);
    format.setCodec("audio/pcm");
    format.setByteOrder(QAudioFormat::LittleEndian);
    format.setSampleType(QAudioFormat::SignedInt);
    if(!audioOutput){
        audioOutput = new QAudioOutput(format, this);
    }
    audioOutput->setBufferSize(8192 * 8);
    
    audioDevice = audioOutput->start();
    if (!audioDevice) {
        qDebug() << "Failed to start audio device";
        file->close();
        file.reset();
        return;
    }
    
    audioOutput->setVolume(50 / 100.0);
    
    buffer = std::make_unique<char[]>(bufferSize);
    
    
    this->currentLyricIndex=0;
    
    
    timer->start(10);
    timer1->start(1000);
    emit Begin();
    
    
    
    connect(this, &Worker::stopPlay, this, &Worker::Pause);
}

